# 오픈뱅킹API를 활용한 자산 관리 어플리케이션

serverless (lambda) 프리티어를 사용하므로 페이지의 로딩이 불안정할 수 있습니다.

**서비스 url**  
 https://n5dbtf6emg.execute-api.us-east-1.amazonaws.com/dev/



**파워포인트**  
 https://docs.google.com/presentation/d/1ecxZHRjoi5hOiV4cSP5-HK2eBKMp0TpO2azjteozCGE/edit?usp=sharing


### 로그인 화면
![image](https://user-images.githubusercontent.com/96038721/169231112-a4ac6fea-70f6-446e-9236-0f0d5ba2926e.png)

### 자산 요약 화면
![image](https://user-images.githubusercontent.com/96038721/169231180-88246b5e-f247-49e3-8555-ac1131963b5d.png)

### 자산 상세 화면
![image](https://user-images.githubusercontent.com/96038721/169238187-d4732bfd-41cc-48cf-8752-64e6354582e1.png)

---

## 개요
팀 단위 프로젝트로 오픈뱅킹 API를 이용하여 이용자의 실제 결제 정보와 금융 정보를 바탕으로 자산을 관리해줄 수 있는 어플리케이션을 개발

실제 서비스를 개발하듯, 기획부터 배포까지 주요한 업무 흐름을 빠짐없이 경험하는 것이 가장 중요한 목표였으며, 나아가 긴밀하게 소통하고 협업 툴 사용에 익숙해지는 것 역시 주요 목표.

## 기획 (자료수집과 프로젝트 파악)
기획단계에서는 아이디어를 수집하고 회의를 진행하였다.
실제 서비스 개발 과정을 모두 경험한다는 목적이 있었으므로, 주제 선정에서 데이터 분석, 인공지능, RESTful API 개발을 포함할 수 있을 법한 주제를 선정하는 것을 전제로 하였고, 일반적인 응용 프로그램의 개발은 최대한 지양하였다.

전제를 제외하면, 주제 선정에서 가장 중요한 기준은 의미있게 사용할 수 있는 데이터셋이나 API가 있냐는 것이었다.

데이터와 API를 구하기 위해 캐글과 데이터거래소 및 공용 데이터포털을 탐색하였으며, 최종적으로 오픈뱅킹 API를 통해 얻은 정보를

-오픈뱅킹 API를 이용해 이용자의 결제 정보와 금융 정보를 받아옵니다.
-이용자의 고정적인 거래 (주기적인 소비)를 탐색함
-이용자의 소비를 분류하여, 분야별 소비금액을 시각화
-이용자의 주간 잔고와 소비 금액을 파악하여 시각화

거래 성향이나 자산 관리 방향을 제시하는 인공지능도 고려되었지만, 학습 데이터 (이용자의 상황이나 위치에 따른 결제 정보)를 구할 수 없었기에 채택되지 않았다.

## 설계 (의도)
오픈뱅킹 API를 사용하여 받아오는 데이터의 종류와 형식을 파악하고, 오픈뱅킹 API 및 이용자로부터 전달받은 데이터를 저장할 DB, DB와 클라이언트를 연결할 API를 설계하였으며, 동시에 API를 통해 데이터를 주고받을 수 있는 화면 기획서를 작성하였다.

#### DB
서비스의 특성상 많은 양의 데이터에 대비할 수 있어야 하며, 이용자와 거래 항목 등, 체계적이고 연관성 있는 데이터에 대한 구축이 필요하므로 RDBMS를 사용하였다. 그 중에서도 점유율이 가장 높은 MySQL을 사용하였다.

데이터베이스의 서버는 따로 구축하는 대신 AWS의 RDS 서버를 사용하는 것으로 DB 서버 구축 비용을 아끼고, 높은 보안과 접근성을 확보할 수 있었다.

AWS RDS에 접속하여 테이블을 구성하고 쿼리문을 테스트하기 위해 MySQL workbench를 사용하였으며, 각 인원별로 어카운트를 생성하여 무분별한 자료 접근을 제한하였다.

오픈뱅킹 API로 전달받는 모든 데이터가 서비스에 필요한 자료가 아니며, 한번에 열람할 수 있는 자료의 양이 정해진 경우도 있었으므로, 오픈뱅킹 API에서 직접 전달받는 대신 서비스 DB에 저장하고 자체 API를 이용하여 불러오게끔 설계 하여 통신 비용을 최소화 하였다.

모든 테이블에서 자료 조회 속도를 높이기 위해 프라이머리 키를 지정한 컬럼을 반드시 포함하도록 하였다. AUTO INCREMENT 제약 조건과 UNSIGNED 제약 조건을 지정하여 최대한 많은 데이터를 저장할 수 있도록 하였다.

비밀번호 등 반드시 필요한 데이터를 받는 컬럼은 NOT NULL 제약 조건을, 이메일 등 중복된 값이 등록되어서는 안되는 컬럼에는 UNIQUE 제약 조건을 지정했다.

현재는 의미가 없더라도 데이터 누적에 따라 의미를 가질 수 있는 데이터도 테이블에 포함하였다. 예를 들어, NOT NULL 제약 조건을 걸고 Expression(기본값)에 CURRENT_TIMESTAMP를 지정하는 것으로 데이터가 기입되는 순간의 가입일시를 기록하였다.

#### 화면
Figma를 이용하여 화면 기획서를 작성하였다.
화면 기획서
https://www.figma.com/file/J3WyfuMNllq9JwvvVASAIg/Ginkgo-v1?node-id=1%3A38

포로토타입 기능을 활용하여, 실제 어플리케이션과 최대한 유사한 화면 이동을 구현하였다.

## 개발 (기술)
프로젝트의 개발은 복수의 인원이 동시에 진행하였으므로 원활한 소스코드 관리를 위하여 클라우드에서 소스코드를 관리할 수 있는 깃 허브를 사용하였다.

각 인원별로 브랜치를 나누어 작업하였으며, 각 기능의 단위 테스트 통과한 경우에만 main 브랜치에 병합하였다. 병합이 완료되면 main 브랜치도 테스트를 실시하여, 이상이 발생하는 경우, 병합 이전으로 버전을 되돌려 main 브랜치의 무결성을 최대한 확보하였다.

또한 한번 여러 브랜치가 동시에 하나의 파일을 수정하는 것은 충돌을 야기할 수 있으므로 최대한 지양 하였다.

사전에 보고되지 않은 풀 리퀘스트는 무조건 반려 하였으며, 풀리퀘스트 전에는 반드시 보고 절차를 진행하여 팀의 작업 진행도를 파악하고, main 브랜치에서의 충돌과 훼손을 방지하였다.

#### 오픈뱅킹 API
서비스의 핵심 데이터인 이용자의 수입과 지출을 알아내기 위해서는 결제 내역 API를 사용해야 했으며, 결제 내역 API 이용을 위해 오픈뱅킹 액세스 토큰이, 액세스 토큰을 얻기 위해 토큰 발급 API가 필요하다. 토큰 발급에는 최초 인증 API로 얻을 수 있는 code값이 필요했으므로, 모든 이용자는 오픈뱅킹 인증 과정을 거쳐야 한다.

최초 인증 API는 다른 오픈뱅킹 API와 달리 HTTP request를 통해 응답 결과로 데이터를 받는 대신,  api URI에 쿼리 스트링을 포함한 URL을 통해 웹 페이지 (브라우저) 상에서 직접 인증을 하고, 파라미터로 전달한 콜백URL의 쿼리 파라미터로 주어지는 code값을 얻어낼 필요가 있었다.

인증이 종료되면 자동으로 콜백URL을 브라우저에 반환하므로, Flask 라이브러리에 포함된 request.args.get('code')메서드를 이용하여 콜백 URL의 'code' 파라미터로 주어진 인자를 가져올 수 있었다.

이용자에게 필요한 것은 서비스의 원활한 이용이지, 시스템의 검토가 아니므로, 인증을 완료하고 code 파라미터 값을 가져오면 곧바로 오픈뱅킹 액세스 토큰 발급 과정을 진행하고, 불필요한 이용자의 액션을 최소화 하였다.

#### 테스트베드 데이터 구성
오픈뱅킹 API는 보안검사를 받지 않은 어플리케이션에게는 실제 거래 데이터를 제공하지 않으므로, 테스트베드에서 구성된 데이터를 사용해야 했다. 단, 구성된 데이터가 실제 서비스의 기능에 맞춰 동작하는지 알아내야 했으므로, 설득력 있는 데이터로 구성할 필요가 있었다.

따라서 지정한 조건에 따라 테스트 데이터를 생성하는 업무 보조 프로그램을 작성하여 보다 설득력 있는 테스트 데이터를 확보하고자 하였다.

#### 이용자 인증
오픈뱅킹 인증과는 별도로, 서비스 외부에서의 활동을 차단하기 위해 서비스 단계에서의 인증도 개발하였다.
이용자 인증에는 Flask에서 지원하는 JWT 형식의 액세스 토큰을 이용자에게 발급하고, 각 API 함수에 @jwt_required() 어노테이션을 이용하였다.

#### 거래 데이터 그룹화
오픈뱅킹 결제내역 API를 통해 받아올 수 있는 데이터중 거래를 분간할 수 있는 데이터는 통장인자가 유일하다.

통장인자 내에서 소비의 분류를 구분지을 수 있는 키워드를 미리 정의하고, 통장인자에 키워드가 포함되어 있는지 여부를 판별하여 분류한다.

그 외로, 이용자가 직접 통장 인자에 대한 분류를 설정할 수 있고, 한번 설정한 통장 인자는 자동으로 분류된다.

#### 거래 고유 번호
모든 이용자의 대부분의 오픈뱅킹 API 요청에는 고래 고유 번호 값이 필요하다. 따라서 서비스 전체에 영향력을 발휘할 수 있게끔, DB에서 관리하였으며, 값을 가져오기 위해 API를 개발하였다.

#### 고정 거래 탐지
오픈뱅킹 결제내역 API를 통해 받아올 수 있는 데이터중 거래를 분간할 수 있는 데이터는 통장인자가 유일하다.

고정 거래는 일정한 주기를 벗어나지 않으므로, 통장인자별로 거래일시를 분리하여, 서로를 빼 거래 주기를 구하고, 거래 주기에 대한 표준 편차를 구하여 고정 거래를 탐지하였다.

연산량을 줄이기 위하여 표준 편차를 구하기 전, 3번 이상 연속된 거래가 없는 경우, 혹은 일주일 이내에서 거래가 발견된 경우는 고정 거래의 기준에 맞지 않는다고 판단하여 제외하였다.

각 결제 범위에 대한 표준 편차를 구해본 결과 약 6개월간 28일부터 30일의 간격을 갖는 월간 고정 거래의 표준편차가 1.08이었으므로 1.1 미만의 표준 편차를 갖는다면 고정 거래로 판별하였다.

#### 시각화
시각화에는 plotly 라이브러리를 사용하였다.
각 차트 종류와 선택 이유 작성

#### 서버리스 호스팅
별도의 서버를 구축하는 대신, AWS 서버리스 환경에서 python flask 프레임워크를 사용하여 개발, GitHub와 연동하여 CI/CD 시스템 구축

Numpy, Pandas, Plotly등의 대형라이브러리 사용을 위해 lambda 레이어 사용.

AWS 클라우드와치를 통해 서버 로그를 확인하고, 에러 발견 및 수정
